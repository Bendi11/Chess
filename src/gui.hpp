#pragma once

#include "imgui.h"
#include "imgui_impl_opengl3.h"
#include "imgui_impl_glfw.h"
#include "portaudio.h"
#include "sndfile.h"


#include <glad/glad.h>
#define GLFW_INCLUDE_NONE
#include <GLFW/glfw3.h>

#include <array>
#include "board.hpp"
#include "log.hpp"

/**
 * @brief A sprite contains all information needed to render an image
 * using OpenGL. This includes size, position, and texture IDs in OpenGL
 * 
 */
struct Sprite
{
public:
    /// Display the sprite at its stored position and size using Dear ImGui's draw list
    void display(void);

    /**
     * @brief Display the sprite at is scale and offset
     * 
     * @param scale The scale size data
     * @param offset The screen coordinates to put the sprite at
     */
    void display(ImVec2 scale, ImVec2 offset);

    /// Load a sprite from a file using the file path
    Sprite(const char* f_name);
    Sprite() = default;

    Sprite(const Sprite& other) = default;

    Sprite& operator =(const Sprite& other) = default;

    /// The size of the sprite rendered in OpenGL
    ImVec2 size;
    /// The position of the sprite rendered in OpenGL
    ImVec2 pos;

private:    
    /// The texture ID of this sprite
    unsigned int m_txid;
    
};

/**
 * @brief The `ChessGui` class contains a `Board` object and displays it, using user input to 
 * configure and manipulate the board
 * @see Board
 * 
 */
class ChessGui
{
public:
    ChessGui();
    /// Initialize all GUI and OpenGL things
    void init(void);

    /// Do the game loop, this function won't return until the window closes
    void loop(void);

    ~ChessGui()
    {
        ImGui_ImplOpenGL3_Shutdown();
        ImGui_ImplGlfw_Shutdown();
        ImGui::DestroyContext();
        glfwDestroyWindow(win);
        glfwTerminate();

        Pa_Terminate();   
        Pa_CloseStream(audio_stream);

        delete move_sound;
        delete capture_sound;
    }
private:

    /// Window that contains all chess menus + display
    GLFWwindow* win = nullptr;

    /// The chess board that we will display
    Board chess;

    /// Convert a chess position struct to screenspace coordinates
    ImVec2 to_screencoords(Position pos)
    {
        ImVec2 ret;
        ret.x = (width_max) ? 
            pos.x * ((float)min / 8) + (float)((max - min) / 2) : 
            pos.x * ((float)min / 8);

        ret.y = (width_max) ? 
            -((int)pos.y - 7) * ((float)min / 8) : 
            -((int)pos.y - 7) * ((float)min / 8) + (float)((max - min) / 2);

        return ret;
    }

    /// Convert screen coordinates to chess positions
    Position to_chesscoords(ImVec2 pos)
    {
        Position ret;
        // I really hate math
        // this was generated by taking the inverse of the function to convert chess coords to screen coords, its really ugly
        ret.x = (width_max) ? 
            (pos.x - (float)((max - min) / 2) ) / ((float)min / 8) :
            pos.x / ((float)min / 8);

        ret.y = (width_max) ? 
            -((int)pos.y - min) / ((float)min / 8) : 
            (-((int)pos.y - max) - (float)((max - min) / 2) ) / ((float)min / 8) ;
        

        return ret;
    }

    bool width_max;
    int max;
    int min;

    std::array<std::array<Sprite, 8>, 8> m_boardsprites; //Sprites that are displayed as the board background

    Sprite moveable;
    std::array<Sprite, 12> piece_sprites; //The sprites of all pieces including colors, indexed by Piece::Type enum and multiplied by 2 if black piece

    PaStream* audio_stream; //The audio stream to write sound effects to
    float* move_sound; 
    float* capture_sound;
    int num_frames;
    
};